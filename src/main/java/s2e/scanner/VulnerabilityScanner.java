package s2e.scanner;

import s2e.model.Finding;
import s2e.pattern.*;
import s2e.taint.SimplifiedTaintAnalyzer;
import s2e.taint.TaintElement;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.google.gson.*;

import com.ibm.wala.classLoader.*;
import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.impl.DefaultEntrypoint;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.core.util.config.AnalysisScopeReader;
import com.ibm.wala.ssa.*;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.MethodReference;
import com.ibm.wala.ipa.callgraph.AnalysisCacheImpl;
import com.ibm.wala.ipa.callgraph.AnalysisOptions;

import java.io.File;
import java.io.FileWriter;
import java.util.*;
import java.util.jar.JarFile;

public class VulnerabilityScanner {
    private final PatternLoader loader;
    private final PatternMatcher matcher;
    private final List<Finding> findings = new ArrayList<>();
    private SimplifiedTaintAnalyzer taintAnalyzer;

    private Map<String, List<String>> cweSources = new HashMap<>();
    private Map<String, List<String>> cweSinks = new HashMap<>();
    private Map<String, List<String>> cweSanitizers = new HashMap<>();

    private Map<String, Boolean> methodReturnsCache = new HashMap<>();

    public VulnerabilityScanner(String patternPath) throws Exception {
        loader = new PatternLoader(patternPath);
        matcher = new PatternMatcher();
        initializeFromJson();
    }

    private void initializeFromJson() {
        JsonObject patterns = loader.getPatterns();
        for (String cweId : patterns.keySet()) {
            JsonObject cweObj = patterns.getAsJsonObject(cweId);

            if (cweObj.has("sources")) {
                JsonArray sourcesArray = cweObj.getAsJsonArray("sources");
                List<String> sources = new ArrayList<>();
                for (JsonElement elem : sourcesArray) {
                    sources.add(elem.getAsString());
                }
                cweSources.put(cweId, sources);
            }

            if (cweObj.has("sinks")) {
                JsonArray sinksArray = cweObj.getAsJsonArray("sinks");
                List<String> sinks = new ArrayList<>();
                for (JsonElement elem : sinksArray) {
                    sinks.add(elem.getAsString());
                }
                cweSinks.put(cweId, sinks);
            }

            if (cweObj.has("sanitizers")) {
                JsonArray sanitizersArray = cweObj.getAsJsonArray("sanitizers");
                List<String> sanitizers = new ArrayList<>();
                for (JsonElement elem : sanitizersArray) {
                    sanitizers.add(elem.getAsString());
                }
                cweSanitizers.put(cweId, sanitizers);
            }
        }
        System.out.println("Loaded " + patterns.keySet().size() + " CWEs from JSON: " + String.join(", ", patterns.keySet()));
    }

    public void scan(String filePath, String classDir, List<String> classDirs, List<String> jarPaths) throws Exception {
        File file = new File(filePath);
        JavaParser parser = new JavaParser();
        ParseResult<CompilationUnit> result = parser.parse(file);

        if (!result.isSuccessful() || !result.getResult().isPresent()) {
            System.out.println("Failed to parse the Java file.");
            return;
        }
        CompilationUnit cu = result.getResult().get();

        String packageName = cu.getPackageDeclaration().map(pd -> pd.getNameAsString() + ".").orElse("");
        String simpleClassName = extractClassName(filePath);
        String fullClassName = packageName + simpleClassName;

        System.out.println("\n=== Starting Vulnerability Analysis ===");

        // Build WALA infrastructure
        AnalysisScope scope = AnalysisScopeReader.instance.makePrimordialScope(null);

        File targetDirFile = new File(classDir);
        if (targetDirFile.exists() && targetDirFile.isDirectory()) {
            scope.addToScope(ClassLoaderReference.Application, new BinaryDirectoryTreeModule(targetDirFile));
        }

        for (String dir : classDirs) {
            File dirFile = new File(dir);
            if (dirFile.exists() && dirFile.isDirectory()) {
                scope.addToScope(ClassLoaderReference.Application, new BinaryDirectoryTreeModule(dirFile));
            }
        }

        for (String jarPath : jarPaths) {
            File jarFile = new File(jarPath);
            if (jarFile.exists() && jarFile.isFile()) {
                scope.addToScope(ClassLoaderReference.Application, new JarFileModule(new JarFile(jarFile)));
            }
        }

        ClassHierarchy cha = ClassHierarchyFactory.make(scope);

        // Build call graph
        List<Entrypoint> entrypoints = new ArrayList<>();
        IClass targetClass = null;
        for (IClass klass : cha) {
            if (klass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                String className = klass.getName().toString();
                String normalizedTarget = "L" + fullClassName.replace('.', '/');
                if (className.equals(normalizedTarget)) {
                    targetClass = klass;
                    for (IMethod method : klass.getDeclaredMethods()) {
                        if (!method.isInit() && !method.isClinit() && !method.isAbstract()) {
                            entrypoints.add(new DefaultEntrypoint(method, cha));
                        }
                    }
                }
            }
        }

        if (entrypoints.isEmpty()) {
            System.out.println("No methods found in target class: " + fullClassName);
            return;
        }

        AnalysisOptions options = new AnalysisOptions(scope, entrypoints);
        options.setReflectionOptions(AnalysisOptions.ReflectionOptions.NONE);
        IAnalysisCacheView cache = new AnalysisCacheImpl();

        CallGraphBuilder<?> builder = Util.makeZeroCFABuilder(Language.JAVA, options, cache, cha);
        CallGraph cg = builder.makeCallGraph(options, null);

        System.out.println("Built call graph with " + cg.getNumberOfNodes() + " nodes");

        // Clear cache for new analysis
        methodReturnsCache.clear();

        // Step 1: Find sources using both JavaParser and WALA
        List<SourceInfo> taintedVariables = findAllSources(cu, cg, cha, targetClass);

        // Step 2: Check if there's an inter-procedural path using WALA
        if (!taintedVariables.isEmpty()) {
            System.out.println("\n=== Checking Inter-procedural Taint Paths ===");
            taintAnalyzer = new SimplifiedTaintAnalyzer(fullClassName, cweSources, cweSinks, cweSanitizers, filePath);

            boolean hasTaintPath = taintAnalyzer.hasTaintPath(classDir, classDirs, jarPaths);

            if (hasTaintPath) {
                Map<String, Map<String, List<TaintElement>>> sourcesByEntryPerCWE =
                        taintAnalyzer.getFoundSourcesByEntryPerCWE();
                Map<String, Map<String, List<TaintElement>>> sinksByEntryPerCWE =
                        taintAnalyzer.getFoundSinksByEntryPerCWE();

                // Check each entry point
                for (String entryMethod : sinksByEntryPerCWE.keySet()) {
                    Map<String, List<TaintElement>> sinksPerCWE = sinksByEntryPerCWE.get(entryMethod);
                    Map<String, List<TaintElement>> sourcesPerCWE = sourcesByEntryPerCWE.getOrDefault(entryMethod, new HashMap<>());

                    for (String cweId : sinksPerCWE.keySet()) {
                        List<TaintElement> sinks = sinksPerCWE.get(cweId);
                        List<TaintElement> sources = sourcesPerCWE.getOrDefault(cweId, new ArrayList<>());

                        if (!sinks.isEmpty() && !sources.isEmpty()) {
                            // Found a complete path from source to sink
                            // Use the sink's line number for the finding
                            int vulnLine = sinks.get(0).line > 0 ? sinks.get(0).line : 1;
                            findings.add(new Finding(filePath, vulnLine, cweId));

                            System.out.println("  âœ— VULNERABILITY FOUND: " + cweId);
                            for (TaintElement source : sources) {
                                // Extract class name from the full class name
                                String className = source.containingClassName;
                                if (className.startsWith("L") && className.endsWith(";")) {
                                    className = className.substring(1, className.length() - 1);
                                }
                                className = className.substring(className.lastIndexOf('/') + 1);

                                // For file name, use the current file if it's the main class being analyzed
                                String sourceFileName = source.sourceFileName;
                                if (sourceFileName == null || "unknown".equals(sourceFileName)) {
                                    sourceFileName = className + ".java";
                                }

                                System.out.println("    Source: " + source.methodName + "() at line " + source.line +
                                        " in " + source.containingMethod + "() [" + sourceFileName + "]");
                            }

                            for (TaintElement sink : sinks) {
                                // Extract class name from the full class name
                                String className = sink.containingClassName;
                                if (className.startsWith("L") && className.endsWith(";")) {
                                    className = className.substring(1, className.length() - 1);
                                }
                                className = className.substring(className.lastIndexOf('/') + 1);

                                // For file name, check if it's the current file being analyzed
                                String sinkFileName = sink.sourceFileName;
                                if (sinkFileName == null || "unknown".equals(sinkFileName)) {
                                    // Check if this sink is in the file we're analyzing
                                    if (sink.containingClassName.contains(fullClassName.replace('.', '/'))) {
                                        sinkFileName = new File(filePath).getName();
                                    } else {
                                        sinkFileName = className + ".java";
                                    }
                                }

                                System.out.println("    Sink: " + sink.methodName + "() at line " + sink.line +
                                        " in " + sink.containingMethod + "() [" + sinkFileName + "]");
                            }
                        }
                    }
                }
            } else {
                System.out.println("  No inter-procedural taint path found");
            }
        }

        System.out.println("\n=== Analysis Complete ===");
        System.out.println("Total vulnerabilities found: " + findings.size());
    }

    private List<SourceInfo> findAllSources(CompilationUnit cu, CallGraph cg, ClassHierarchy cha, IClass targetClass) {
        Set<SourceInfo> allSources = new HashSet<>();

        // 1. Find direct sources using JavaParser (accurate line numbers)
        List<SourceInfo> directSources = findSourcesAndTaint(cu);
        allSources.addAll(directSources);

        // 2. Find indirect sources using WALA
        List<SourceInfo> indirectSources = findIndirectSourcesWithWALA(cu, cg, cha, targetClass);
        allSources.addAll(indirectSources);

        // Remove duplicates and sort by line number
        List<SourceInfo> uniqueSources = new ArrayList<>(allSources);
        uniqueSources.sort((a, b) -> Integer.compare(a.line, b.line));

        System.out.println("\n=== Found Sources ===");
        for (SourceInfo source : uniqueSources) {
            System.out.println("  Line " + source.line + ": " + source.sourceMethod +
                    " in " + source.containingMethod);
        }

        return uniqueSources;
    }

    private List<SourceInfo> findIndirectSourcesWithWALA(CompilationUnit cu, CallGraph cg,
                                                         ClassHierarchy cha, IClass targetClass) {
        List<SourceInfo> sources = new ArrayList<>();

        // Find all variable assignments from method calls in the target class
        cu.findAll(VariableDeclarator.class).forEach(varDecl -> {
            if (varDecl.getInitializer().isPresent()) {
                Expression init = varDecl.getInitializer().get();
                if (init.isMethodCallExpr()) {
                    MethodCallExpr call = init.asMethodCallExpr();
                    if (methodReturnsTaintedData(call, cg, cha)) {
                        String varName = varDecl.getNameAsString();
                        int line = init.getRange().map(r -> r.begin.line).orElse(-1);
                        String containingMethod = varDecl.findAncestor(MethodDeclaration.class)
                                .map(MethodDeclaration::getNameAsString).orElse("unknown");
                        String methodName = call.getNameAsString();

                        // Get full method signature if possible
                        if (call.getScope().isPresent()) {
                            methodName = call.getScope().get().toString() + "." + methodName;
                        }

                        sources.add(new SourceInfo(varName, methodName, line, containingMethod));
                        System.out.println("  Found indirect source: " + methodName +
                                " at line " + line + " (returns tainted data)");
                    }
                }
            }
        });

        // Also check assignments
        cu.findAll(AssignExpr.class).forEach(assign -> {
            if (assign.getTarget().isNameExpr() && assign.getValue().isMethodCallExpr()) {
                MethodCallExpr call = assign.getValue().asMethodCallExpr();
                if (methodReturnsTaintedData(call, cg, cha)) {
                    String varName = assign.getTarget().asNameExpr().getNameAsString();
                    int line = assign.getValue().getRange().map(r -> r.begin.line).orElse(-1);
                    String containingMethod = assign.findAncestor(MethodDeclaration.class)
                            .map(MethodDeclaration::getNameAsString).orElse("unknown");
                    String methodName = call.getNameAsString();

                    if (call.getScope().isPresent()) {
                        methodName = call.getScope().get().toString() + "." + methodName;
                    }

                    sources.add(new SourceInfo(varName, methodName, line, containingMethod));
                    System.out.println("  Found indirect source: " + methodName +
                            " at line " + line + " (returns tainted data)");
                }
            }
        });

        return sources;
    }

    private boolean methodReturnsTaintedData(MethodCallExpr call, CallGraph cg, ClassHierarchy cha) {
        String methodName = call.getNameAsString();
        String className = null;

        // Try to resolve the class name
        if (call.getScope().isPresent()) {
            Expression scope = call.getScope().get();
            if (scope.isObjectCreationExpr()) {
                className = scope.asObjectCreationExpr().getType().getNameAsString();
            }
        }

        // Find matching methods in the call graph
        for (CGNode node : cg) {
            IMethod method = node.getMethod();
            if (method.getName().toString().equals(methodName)) {
                // Check class name if we have it
                if (className != null) {
                    String methodClassName = method.getDeclaringClass().getName().getClassName().toString();
                    if (!methodClassName.contains(className)) {
                        continue;
                    }
                }

                // Check if this method returns tainted data
                if (methodReturnsTaintedData(method.getReference(), cg)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean methodReturnsTaintedData(MethodReference methodRef, CallGraph cg) {
        // Check cache first
        String cacheKey = methodRef.getSignature();
        if (methodReturnsCache.containsKey(cacheKey)) {
            return methodReturnsCache.get(cacheKey);
        }

        boolean returnsTainted = false;
        Set<CGNode> methodNodes = cg.getNodes(methodRef);

        for (CGNode node : methodNodes) {
            if (!isApplicationClass(node)) continue;

            IR ir = node.getIR();
            if (ir == null) continue;

            // Find all return statements
            for (SSAInstruction inst : ir.getInstructions()) {
                if (inst instanceof SSAReturnInstruction) {
                    SSAReturnInstruction ret = (SSAReturnInstruction) inst;
                    if (ret.getNumberOfUses() > 0) {
                        // Trace back where the returned value comes from
                        int returnValue = ret.getUse(0);
                        if (traceValueToSource(node, returnValue, new HashSet<>(), cg)) {
                            returnsTainted = true;
                            break;
                        }
                    }
                }
            }
            if (returnsTainted) break;
        }

        // Cache the result
        methodReturnsCache.put(cacheKey, returnsTainted);
        return returnsTainted;
    }

    private boolean traceValueToSource(CGNode node, int value, Set<String> visited, CallGraph cg) {
        // Avoid infinite recursion
        String key = node.getMethod().getSignature() + ":" + value;
        if (!visited.add(key)) return false;

        IR ir = node.getIR();
        if (ir == null) return false;

        DefUse du = node.getDU();
        SSAInstruction def = du.getDef(value);

        if (def == null) {
            // Check if it's a parameter
            int paramIndex = value - 1; // SSA values start at 1
            if (paramIndex >= 0 && paramIndex < node.getMethod().getNumberOfParameters()) {
                // This is a parameter - need to check callers
                return traceParameterToCaller(node, paramIndex, visited, cg);
            }
            return false;
        }

        // Check if this is a direct source call
        if (def instanceof SSAInvokeInstruction) {
            SSAInvokeInstruction invoke = (SSAInvokeInstruction) def;
            String sig = invoke.getDeclaredTarget().getSignature();

            // Check against ALL configured sources
            for (List<String> sources : cweSources.values()) {
                if (sources.contains(sig)) {
                    return true;
                }
            }

            // If not a direct source, check if the called method returns tainted data
            if (invoke.hasDef() && invoke.getDef() == value) {
                if (methodReturnsTaintedData(invoke.getDeclaredTarget(), cg)) {
                    return true;
                }
            }
        }

        // Trace through phi nodes
        if (def instanceof SSAPhiInstruction) {
            SSAPhiInstruction phi = (SSAPhiInstruction) def;
            for (int i = 0; i < phi.getNumberOfUses(); i++) {
                if (traceValueToSource(node, phi.getUse(i), visited, cg)) {
                    return true;
                }
            }
        }

        // Trace through field reads
        if (def instanceof SSAGetInstruction) {
            // For now, conservatively assume fields could be tainted
            // In a more sophisticated analysis, you'd track field writes
            return false;
        }

        // Trace through other instructions that might propagate taint
        if (def.hasDef() && def.getNumberOfUses() > 0) {
            // Check all uses to see if any come from tainted sources
            for (int i = 0; i < def.getNumberOfUses(); i++) {
                if (traceValueToSource(node, def.getUse(i), visited, cg)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean traceParameterToCaller(CGNode callee, int paramIndex, Set<String> visited, CallGraph cg) {
        // Find all callers
        Iterator<CGNode> callers = cg.getPredNodes(callee);
        while (callers.hasNext()) {
            CGNode caller = callers.next();
            if (!isApplicationClass(caller)) continue;

            IR callerIR = caller.getIR();
            if (callerIR == null) continue;

            // Find calls to the callee
            for (SSAInstruction inst : callerIR.getInstructions()) {
                if (inst instanceof SSAInvokeInstruction) {
                    SSAInvokeInstruction invoke = (SSAInvokeInstruction) inst;

                    // Check if this invokes our callee
                    Set<CGNode> targets = cg.getPossibleTargets(caller, invoke.getCallSite());
                    if (targets.contains(callee)) {
                        // Get the actual argument passed
                        int argIndex = paramIndex + (invoke.isStatic() ? 0 : 1);
                        if (argIndex < invoke.getNumberOfUses()) {
                            int argValue = invoke.getUse(argIndex);
                            if (traceValueToSource(caller, argValue, visited, cg)) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean isApplicationClass(CGNode node) {
        return node.getMethod().getDeclaringClass().getClassLoader()
                .getReference().equals(ClassLoaderReference.Application);
    }

    private List<SourceInfo> findSourcesAndTaint(CompilationUnit cu) {
        List<SourceInfo> tainted = new ArrayList<>();

        System.out.println("\n=== Finding Direct Sources ===");

        // Find variable declarations initialized with sources
        cu.findAll(VariableDeclarator.class).forEach(varDecl -> {
            if (varDecl.getInitializer().isPresent()) {
                Expression init = varDecl.getInitializer().get();
                String sourceMethod = getSourceMethod(init);
                if (sourceMethod != null) {
                    String varName = varDecl.getNameAsString();
                    int line = init.getRange().map(r -> r.begin.line).orElse(-1);
                    String containingMethod = varDecl.findAncestor(MethodDeclaration.class)
                            .map(MethodDeclaration::getNameAsString).orElse("unknown");
                    tainted.add(new SourceInfo(varName, sourceMethod, line, containingMethod));
                    System.out.println("  Found direct source: " + sourceMethod + " assigned to " + varName + " at line " + line + " in " + containingMethod);
                }
            }
        });

        // Find assignments from sources
        cu.findAll(AssignExpr.class).forEach(assign -> {
            if (assign.getTarget().isNameExpr()) {
                String sourceMethod = getSourceMethod(assign.getValue());
                if (sourceMethod != null) {
                    String varName = assign.getTarget().asNameExpr().getNameAsString();
                    int line = assign.getValue().getRange().map(r -> r.begin.line).orElse(-1);
                    String containingMethod = assign.findAncestor(MethodDeclaration.class)
                            .map(MethodDeclaration::getNameAsString).orElse("unknown");
                    tainted.add(new SourceInfo(varName, sourceMethod, line, containingMethod));
                    System.out.println("  Found direct source: " + sourceMethod + " assigned to " + varName + " at line " + line + " in " + containingMethod);
                }
            }
        });

        return tainted;
    }

    private String getSourceMethod(Expression expr) {
        if (expr.isMethodCallExpr()) {
            MethodCallExpr call = expr.asMethodCallExpr();
            String methodName = call.getNameAsString();

            // Check if this is a known source
            for (List<String> sources : cweSources.values()) {
                if (sources.stream().anyMatch(sig -> sig.contains(methodName))) {
                    // Special check for System.getenv
                    if (methodName.equals("getenv") && call.getScope().isPresent() &&
                            call.getScope().get().toString().equals("System")) {
                        return "System.getenv";
                    }
                    return methodName;
                }
            }
        }
        return null;
    }

    private String extractClassName(String filePath) {
        File file = new File(filePath);
        String fileName = file.getName();
        if (fileName.endsWith(".java")) {
            return fileName.substring(0, fileName.length() - 5);
        }
        return fileName;
    }

    public static void exportFindingsToJson(List<Finding> findings, String outputPath) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(outputPath)) {
            gson.toJson(findings, writer);
            System.out.println("\nExported results to " + outputPath);
        } catch (Exception e) {
            System.out.println("Error writing JSON: " + e.getMessage());
        }
    }

    public List<Finding> getFindings() {
        return findings;
    }

    private static class SourceInfo {
        String variable;
        String sourceMethod;
        int line;
        String containingMethod;

        SourceInfo(String variable, String sourceMethod, int line, String containingMethod) {
            this.variable = variable;
            this.sourceMethod = sourceMethod;
            this.line = line;
            this.containingMethod = containingMethod;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            SourceInfo that = (SourceInfo) o;
            return line == that.line &&
                    Objects.equals(variable, that.variable) &&
                    Objects.equals(containingMethod, that.containingMethod);
        }

        @Override
        public int hashCode() {
            return Objects.hash(variable, line, containingMethod);
        }
    }
}