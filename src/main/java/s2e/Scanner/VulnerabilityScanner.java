package s2e.Scanner;

import com.github.javaparser.ast.expr.MethodCallExpr;
import s2e.PatchGenerator.ToJson;
import s2e.PatternAnalyzer.*;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;

import com.google.gson.*;

import java.io.File;
import java.io.FileWriter;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import s2e.WalaAnalyzer.WalaAnalyzer;

public class VulnerabilityScanner {
    private final PatternLoader loader;
    private final PatternMatcher matcher;
    private final List<ToJson> findings = new java.util.ArrayList<>();

    public VulnerabilityScanner(String patternPath) throws Exception {
        loader = new PatternLoader(patternPath);
        matcher = new PatternMatcher();
    }

    public void scan(String filePath, String classDir, List<String> classDirs, List<String> jarPaths) throws Exception {
        File file = new File(filePath);
        JavaParser parser = new JavaParser();
        ParseResult<CompilationUnit> result = parser.parse(file);

        if (!result.isSuccessful() || !result.getResult().isPresent()) {
            System.out.println("Failed to parse the Java file.");
            return;
        }
        CompilationUnit cu = result.getResult().get();
        JsonObject patterns = loader.getPatterns();

        System.out.println("\n=== Starting AST Pattern Analysis ===");

        // ---- AST pattern matching ----
        for (Map.Entry<String, JsonElement> entry : patterns.entrySet()) {
            String cweId = entry.getKey();
            JsonObject cweObj = entry.getValue().getAsJsonObject();
            if (!cweObj.has("ast_patterns")) continue;

            System.out.println("\nChecking for " + cweId + ": " + cweObj.get("name").getAsString());

            JsonArray astPatterns = cweObj.getAsJsonArray("ast_patterns");
            for (JsonElement patEl : astPatterns) {
                JsonObject pattern = patEl.getAsJsonObject();
                final int[] foundCount = {0};
                cu.walk(node -> {
                    if (matcher.matchesPattern(node, pattern)) {
                        int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                        System.out.println("  ✗ VULNERABILITY FOUND: " + cweId +
                                " (" + pattern.get("node_type").getAsString() + ") at line " + line);
                        findings.add(new ToJson(filePath, line, cweId));
                        foundCount[0]++;
                    }
                });
                if (foundCount[0] == 0 && pattern.get("node_type").getAsString().equals("MethodCallExpr")) {
                    System.out.println("    No " + pattern.get("node_type").getAsString() + " patterns found");
                }
            }
        }

        // ---- Additional file analysis for CWE-15 ----
        if (patterns.has("CWE-15") && classDir != null) {
            System.out.println("\n=== Checking related files for CWE-15 patterns ===");

            // For Juliet tests, check all related files (54a through 54e)
            File dir = new File(new File(filePath).getParent());
            String baseFileName = new File(filePath).getName().replace("_54a.java", "");

            for (char suffix = 'a'; suffix <= 'e'; suffix++) {
                String relatedFile = dir.getPath() + File.separator + baseFileName + "_54" + suffix + ".java";
                File f = new File(relatedFile);

                if (f.exists() && !f.getAbsolutePath().equals(new File(filePath).getAbsolutePath())) {
                    System.out.println("  Checking related file: " + f.getName());

                    try {
                        ParseResult<CompilationUnit> relatedResult = parser.parse(f);
                        if (relatedResult.isSuccessful() && relatedResult.getResult().isPresent()) {
                            CompilationUnit relatedCu = relatedResult.getResult().get();

                            JsonArray astPatterns = patterns.get("CWE-15").getAsJsonObject().getAsJsonArray("ast_patterns");
                            for (JsonElement patEl : astPatterns) {
                                JsonObject pattern = patEl.getAsJsonObject();
                                relatedCu.walk(node -> {
                                    if (matcher.matchesPattern(node, pattern)) {
                                        int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                        System.out.println("    ✗ VULNERABILITY FOUND: CWE-15 in " + f.getName() + " at line " + line);
                                        findings.add(new ToJson(relatedFile, line, "CWE-15"));
                                    }
                                });
                            }
                        }
                    } catch (Exception e) {
                        System.out.println("    Error parsing " + f.getName() + ": " + e.getMessage());
                    }
                }
            }

            // Also check if System.getenv() is used as a source
            System.out.println("\n  Checking for taint sources in main file:");
            cu.findAll(MethodCallExpr.class).forEach(call -> {
                if (call.getScope().isPresent() && call.getScope().get().toString().equals("System")
                        && call.getNameAsString().equals("getenv")) {
                    int line = call.getRange().map(r -> r.begin.line).orElse(-1);
                    System.out.println("    Found potential taint source: System.getenv() at line " + line);
                }
            });
        }

        System.out.println("\n=== Analysis Complete ===");
        System.out.println("Total vulnerabilities found: " + findings.size());
    }

    public static void exportFindingsToJson(List<ToJson> findings, String outputPath) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(outputPath)) {
            gson.toJson(findings, writer);
            System.out.println("\nExported results to " + outputPath);
        } catch (Exception e) {
            System.out.println("Error writing JSON: " + e.getMessage());
        }
    }

    public java.util.List<ToJson> getFindings() {
        return findings;
    }
}