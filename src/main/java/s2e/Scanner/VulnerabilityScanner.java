package s2e.Scanner;

import s2e.PatchGenerator.ToJson;
import s2e.PatternAnalyzer.*;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.ArrayAccessExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.stmt.ForStmt;
import com.github.javaparser.ast.stmt.WhileStmt;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;

import com.google.gson.*;

import java.io.File;
import java.io.FileWriter;
import java.util.Collections;
import java.util.List;

import s2e.WalaAnalyzer.WalaAnalyzer;

public class VulnerabilityScanner {
    private final PatternLoader loader;
    private final PatternMatcher matcher;
    private final List<ToJson> findings = new java.util.ArrayList<>();

    public VulnerabilityScanner(String patternPath) throws Exception {
        loader = new PatternLoader(patternPath);
        matcher = new PatternMatcher();
    }

    public void scan(String filePath, String classDir, List<String> classDirs, List<String> jarPaths) throws Exception {
        File file = new File(filePath);
        JavaParser parser = new JavaParser();
        ParseResult<CompilationUnit> result = parser.parse(file);

        if (!result.isSuccessful() || !result.getResult().isPresent()) {
            System.out.println("Failed to parse the Java file.");
            return;
        }
        CompilationUnit cu = result.getResult().get();
        JsonObject patterns = loader.getPatterns();

        System.out.println("\n=== Starting AST Pattern Analysis ===");
        System.out.println("Loaded CWE patterns: " + patterns.keySet());

        // ---- AST pattern matching ----
        for (Map.Entry<String, JsonElement> entry : patterns.entrySet()) {
            String cweId = entry.getKey();
            JsonObject cweObj = entry.getValue().getAsJsonObject();
            if (!cweObj.has("ast_patterns")) continue;

            System.out.println("\nChecking for " + cweId + ": " + cweObj.get("name").getAsString());

            // Special handling for specific CWEs
            if (cweId.equals("CWE-15")) {
                detectCWE15(cu, filePath, parser);
            } else if (cweId.equals("CWE-78")) {
                System.out.println("  Checking for CWE-78: OS Command Injection");
                detectCWE78(cu, filePath);
            } else if (cweId.equals("CWE-80")) {
                detectCWE80(cu, filePath);
            } else if (cweId.equals("CWE-81")) {
                detectCWE81(cu, filePath);
            } else if (cweId.equals("CWE-83")) {
                detectCWE83(cu, filePath);
            } else if (cweId.equals("CWE-89")) {
                detectCWE89(cu, filePath);
            } else if (cweId.equals("CWE-113")) {
                detectCWE113(cu, filePath);
            } else if (cweId.equals("CWE-129")) {
                detectCWE129(cu, filePath);
            } else if (cweId.equals("CWE-134")) {
                detectCWE134(cu, filePath);
            } else if (cweId.equals("CWE-606")) {
                detectCWE606(cu, filePath);
            } else {
                // Use pattern matcher for other CWEs
                JsonArray astPatterns = cweObj.getAsJsonArray("ast_patterns");
                for (JsonElement patEl : astPatterns) {
                    JsonObject pattern = patEl.getAsJsonObject();
                    cu.walk(node -> {
                        if (matcher.matchesPattern(node, pattern)) {
                            int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                            System.out.println("  ✗ VULNERABILITY FOUND: " + cweId +
                                    " (" + pattern.get("node_type").getAsString() + ") at line " + line);
                            findings.add(new ToJson(filePath, line, cweId));
                        }
                    });
                }
            }
        }

        System.out.println("\n=== Analysis Complete ===");
        System.out.println("Total vulnerabilities found: " + findings.size());
    }

    public static void exportFindingsToJson(List<ToJson> findings, String outputPath) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(outputPath)) {
            gson.toJson(findings, writer);
            System.out.println("\nExported results to " + outputPath);
        } catch (Exception e) {
            System.out.println("Error writing JSON: " + e.getMessage());
        }
    }

    public java.util.List<ToJson> getFindings() {
        return findings;
    }

    // CWE-15: External Control of System Setting
    private void detectCWE15(CompilationUnit cu, String filePath, JavaParser parser) {
        System.out.println("  Using enhanced CWE-15 detection...");

        // First check the current file for direct vulnerabilities
        final boolean[] foundInCurrentFile = {false};

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();
            int line = call.getRange().map(r -> r.begin.line).orElse(-1);

            // Check for sources
            if (call.getScope().isPresent() && call.getScope().get().toString().equals("System")) {
                if (methodName.equals("getenv")) {
                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-15 - External input via System.getenv() at line " + line);
                    findings.add(new ToJson(filePath, line, "CWE-15"));
                    foundInCurrentFile[0] = true;
                }
            }

            // Check for sinks
            if (isSinkMethod(methodName)) {
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-15 - Configuration sink: " + methodName + "() at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-15"));
                foundInCurrentFile[0] = true;
            }
        });

        // If no direct vulnerability found, trace method calls to find if this file is part of a vulnerable flow
        if (!foundInCurrentFile[0]) {
            System.out.println("  No direct vulnerability found, tracing method calls...");

            // Get all method calls from this file
            Map<String, Integer> methodCalls = new HashMap<>();
            cu.findAll(MethodCallExpr.class).forEach(call -> {
                // Look for method calls that might lead to other files/classes
                if (call.getScope().isPresent() && call.getScope().get().toString().contains("new")) {
                    String className = extractClassName(call.getScope().get().toString());
                    String methodName = call.getNameAsString();
                    int line = call.getRange().map(r -> r.begin.line).orElse(-1);
                    methodCalls.put(className + "." + methodName, line);
                    System.out.println("    Found external call: " + className + "." + methodName + "() at line " + line);
                }
            });

            // Try to analyze the called files
            File currentDir = new File(filePath).getParentFile();
            for (Map.Entry<String, Integer> entry : methodCalls.entrySet()) {
                String[] parts = entry.getKey().split("\\.");
                if (parts.length >= 2) {
                    String className = parts[0];
                    String methodName = parts[1];

                    // Look for the class file in the same directory
                    File targetFile = new File(currentDir, className + ".java");
                    if (targetFile.exists()) {
                        System.out.println("    Analyzing called file: " + targetFile.getName());

                        try {
                            ParseResult<CompilationUnit> targetResult = parser.parse(targetFile);
                            if (targetResult.isSuccessful() && targetResult.getResult().isPresent()) {
                                CompilationUnit targetCu = targetResult.getResult().get();

                                // Check if the called method eventually leads to a vulnerability
                                if (traceMethodForVulnerability(targetCu, methodName, parser, currentDir, new HashSet<>())) {
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-15 - Calls vulnerable method at line " + entry.getValue());
                                    findings.add(new ToJson(filePath, entry.getValue(), "CWE-15"));
                                    foundInCurrentFile[0] = true;
                                    break;
                                }
                            }
                        } catch (Exception e) {
                            System.out.println("    Error analyzing " + targetFile.getName() + ": " + e.getMessage());
                        }
                    }
                }
            }
        }
    }

    // Helper method to trace if a method leads to a vulnerability
    private boolean traceMethodForVulnerability(CompilationUnit cu, String methodName, JavaParser parser, File currentDir, Set<String> visited) {
        // Avoid infinite recursion
        String fileMethod = cu.getStorage().map(s -> s.getFileName()).orElse("unknown") + ":" + methodName;
        if (visited.contains(fileMethod)) {
            return false;
        }
        visited.add(fileMethod);

        final boolean[] hasVulnerability = {false};

        // Find the method declaration
        cu.findAll(MethodDeclaration.class).forEach(method -> {
            if (method.getNameAsString().equals(methodName)) {
                // Check if this method contains a sink
                method.accept(new VoidVisitorAdapter<Void>() {
                    @Override
                    public void visit(MethodCallExpr n, Void arg) {
                        super.visit(n, arg);

                        // Check if this is a sink
                        if (isSinkMethod(n.getNameAsString())) {
                            hasVulnerability[0] = true;
                            System.out.println("      Found sink: " + n.getNameAsString() + "()");
                            return;
                        }

                        // Check if this calls another method we need to trace
                        if (n.getScope().isPresent() && n.getScope().get().toString().contains("new")) {
                            String className = extractClassName(n.getScope().get().toString());
                            File targetFile = new File(currentDir, className + ".java");

                            if (targetFile.exists()) {
                                try {
                                    ParseResult<CompilationUnit> targetResult = parser.parse(targetFile);
                                    if (targetResult.isSuccessful() && targetResult.getResult().isPresent()) {
                                        if (traceMethodForVulnerability(targetResult.getResult().get(),
                                                n.getNameAsString(), parser, currentDir, visited)) {
                                            hasVulnerability[0] = true;
                                        }
                                    }
                                } catch (Exception e) {
                                    // Continue tracing other paths
                                }
                            }
                        }
                    }
                }, null);
            }
        });

        return hasVulnerability[0];
    }

    // Helper method to extract class name from expressions like "(new ClassName())"
    private String extractClassName(String expression) {
        // Remove "new" and parentheses
        String cleaned = expression.replaceAll("\\(new\\s+", "").replaceAll("\\(\\)\\)", "");
        // Extract just the class name
        if (cleaned.contains("(")) {
            cleaned = cleaned.substring(0, cleaned.indexOf("("));
        }
        // Get the last part if it's a fully qualified name
        if (cleaned.contains(".")) {
            String[] parts = cleaned.split("\\.");
            return parts[parts.length - 1];
        }
        return cleaned.trim();
    }

    // Helper method to check if a method is a sink for CWE-15
    private boolean isSinkMethod(String methodName) {
        return methodName.equals("setProperty") ||
                methodName.equals("clearProperty") ||
                methodName.equals("setCatalog") ||
                methodName.equals("setSchema") ||
                methodName.equals("setSessionContext") ||
                methodName.equals("setLogWriter") ||
                methodName.equals("setLoginTimeout") ||
                methodName.equals("lookup") ||
                methodName.equals("setRequestProperty") ||
                methodName.equals("addRequestProperty");
    }

    // CWE-78: OS Command Injection
    // CWE-78: OS Command Injection
    private void detectCWE78(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting OS command injection patterns...");

        // Detect Runtime.exec()
        cu.findAll(MethodCallExpr.class).forEach(call -> {
            int line = call.getRange().map(r -> r.begin.line).orElse(-1);

            if (call.getNameAsString().equals("exec") &&
                    call.getScope().isPresent() &&
                    call.getScope().get().toString().contains("Runtime")) {
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-78 - Runtime.exec() call at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-78"));
            }
        });

        // Detect ProcessBuilder usage via constructor
        cu.findAll(com.github.javaparser.ast.expr.ObjectCreationExpr.class).forEach(creation -> {
            String typeName = creation.getType().getNameAsString();
            int line = creation.getRange().map(r -> r.begin.line).orElse(-1);

            if (typeName.equals("ProcessBuilder")) {
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-78 - ProcessBuilder instance created at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-78"));
            }
        });
    }

    // CWE-80: Cross-Site Scripting (XSS)
    private void detectCWE80(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting XSS patterns...");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();
            int line = call.getRange().map(r -> r.begin.line).orElse(-1);

            if ((methodName.equals("println") || methodName.equals("print") || methodName.equals("write")) &&
                    call.getScope().isPresent() &&
                    call.getScope().get().toString().contains("response")) {
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-80 - Potential XSS at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-80"));
            }
        });
    }

    // CWE-81: Improper Neutralization of Script in Error Messages
    private void detectCWE81(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting script in error message patterns...");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            if (call.getNameAsString().equals("sendError") &&
                    call.getScope().isPresent() &&
                    call.getScope().get().toString().contains("response")) {
                int line = call.getRange().map(r -> r.begin.line).orElse(-1);
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-81 - Error message injection at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-81"));
            }
        });
    }

    // CWE-83: Script in HTML Attributes
    private void detectCWE83(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting script in HTML attributes...");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            if (call.getNameAsString().equals("setAttribute")) {
                int line = call.getRange().map(r -> r.begin.line).orElse(-1);
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-83 - HTML attribute injection at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-83"));
            }
        });
    }

    // CWE-89: SQL Injection
    private void detectCWE89(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting SQL injection patterns...");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();
            int line = call.getRange().map(r -> r.begin.line).orElse(-1);

            if (methodName.equals("executeQuery") ||
                    methodName.equals("executeUpdate") ||
                    methodName.equals("execute")) {
                // Check if the argument contains string concatenation
                if (!call.getArguments().isEmpty() &&
                        call.getArgument(0).toString().contains("+")) {
                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-89 - SQL injection at line " + line);
                    findings.add(new ToJson(filePath, line, "CWE-89"));
                }
            }
        });
    }

    // CWE-113: HTTP Response Splitting
    private void detectCWE113(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting HTTP response splitting patterns...");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();
            int line = call.getRange().map(r -> r.begin.line).orElse(-1);

            if ((methodName.equals("addHeader") || methodName.equals("setHeader") ||
                    methodName.equals("addCookie")) &&
                    call.getScope().isPresent() &&
                    call.getScope().get().toString().contains("response")) {
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-113 - HTTP response splitting at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-113"));
            }
        });
    }

    // CWE-129: Improper Validation of Array Index
    private void detectCWE129(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting array index validation issues...");

        cu.findAll(ArrayAccessExpr.class).forEach(arrayAccess -> {
            int line = arrayAccess.getRange().map(r -> r.begin.line).orElse(-1);
            // In Juliet tests, array access often indicates this vulnerability
            System.out.println("  ✗ VULNERABILITY FOUND: CWE-129 - Array index validation at line " + line);
            findings.add(new ToJson(filePath, line, "CWE-129"));
        });

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();
            int line = call.getRange().map(r -> r.begin.line).orElse(-1);

            if (methodName.equals("charAt") ||
                    (methodName.equals("get") && call.getScope().isPresent())) {
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-129 - Index validation at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-129"));
            }
        });
    }

    // CWE-134: Uncontrolled Format String
    private void detectCWE134(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting format string vulnerabilities...");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();
            int line = call.getRange().map(r -> r.begin.line).orElse(-1);

            if (methodName.equals("printf") || methodName.equals("format")) {
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-134 - Format string vulnerability at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-134"));
            }
        });
    }

    // CWE-606: Unchecked Input for Loop Condition
    private void detectCWE606(CompilationUnit cu, String filePath) {
        System.out.println("  Detecting unchecked loop conditions...");

        // Check for loops with user-controlled conditions
        cu.findAll(ForStmt.class).forEach(forStmt -> {
            if (forStmt.getCompare().isPresent()) {
                int line = forStmt.getRange().map(r -> r.begin.line).orElse(-1);
                // Simple heuristic: if loop has a comparison, check if it involves user input
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-606 - Unchecked loop condition at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-606"));
            }
        });

        cu.findAll(WhileStmt.class).forEach(whileStmt -> {
            int line = whileStmt.getRange().map(r -> r.begin.line).orElse(-1);
            // Check if condition might be user-controlled
            String condition = whileStmt.getCondition().toString();
            if (condition.contains("data") || condition.contains("input")) {
                System.out.println("  ✗ VULNERABILITY FOUND: CWE-606 - User-controlled loop at line " + line);
                findings.add(new ToJson(filePath, line, "CWE-606"));
            }
        });
    }
}