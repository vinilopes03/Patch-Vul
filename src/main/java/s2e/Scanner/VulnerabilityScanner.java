package s2e.Scanner;

import s2e.PatchGenerator.ToJson;
import s2e.PatternAnalyzer.*;
import s2e.WalaIntegration.SimplifiedTaintAnalyzer;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.stmt.ForStmt;
import com.github.javaparser.ast.stmt.WhileStmt;
import com.github.javaparser.ast.stmt.DoStmt;
import com.google.gson.*;
import s2e.WalaIntegration.*;
import java.io.File;
import java.io.FileWriter;
import java.util.*;

public class VulnerabilityScanner {
    private final PatternLoader loader;
    private final PatternMatcher matcher;
    private final List<ToJson> findings = new java.util.ArrayList<>();
    private SimplifiedTaintAnalyzer taintAnalyzer;

    // Track sources and sinks from patterns
    private Map<String, List<String>> cweSources = new HashMap<>();
    private Map<String, List<String>> cweSinks = new HashMap<>();

    public VulnerabilityScanner(String patternPath) throws Exception {
        loader = new PatternLoader(patternPath);
        matcher = new PatternMatcher();
        initializeSourcesAndSinks();
    }

    private void initializeSourcesAndSinks() {
        // CWE-15: External Control of System or Configuration Setting
        cweSources.put("CWE-15", Arrays.asList(
                "java.lang.System.getenv(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "java.io.BufferedReader.readLine()Ljava/lang/String;",
                "java.util.Scanner.nextLine()Ljava/lang/String;"
        ));
        cweSinks.put("CWE-15", Arrays.asList(
                "java.lang.System.setProperty(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                "java.lang.System.clearProperty(Ljava/lang/String;)Ljava/lang/String;",
                "java.sql.Connection.setCatalog(Ljava/lang/String;)V",
                "java.sql.Connection.setSchema(Ljava/lang/String;)V",
                "javax.naming.InitialContext.lookup(Ljava/lang/String;)Ljava/lang/Object;",
                "java.net.URLConnection.setRequestProperty(Ljava/lang/String;Ljava/lang/String;)V",
                "java.net.URLConnection.addRequestProperty(Ljava/lang/String;Ljava/lang/String;)V",
                "java.sql.Connection.setClientInfo(Ljava/lang/String;Ljava/lang/String;)V"
        ));

        // CWE-78: OS Command Injection
        cweSources.put("CWE-78", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "java.io.BufferedReader.readLine()Ljava/lang/String;",
                "java.util.Scanner.nextLine()Ljava/lang/String;",
                "java.util.Scanner.next()Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getHeader(Ljava/lang/String;)Ljava/lang/String;",
                "java.lang.System.getProperty(Ljava/lang/String;)Ljava/lang/String;"
        ));
        cweSinks.put("CWE-78", Arrays.asList(
                "java.lang.Runtime.exec(Ljava/lang/String;)Ljava/lang/Process;",
                "java.lang.Runtime.exec([Ljava/lang/String;)Ljava/lang/Process;",
                "java.lang.Runtime.exec(Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Process;",
                "java.lang.ProcessBuilder.command([Ljava/lang/String;)Ljava/lang/ProcessBuilder;",
                "java.lang.ProcessBuilder.command(Ljava/util/List;)Ljava/lang/ProcessBuilder;",
                "java.lang.ProcessBuilder.start()Ljava/lang/Process;"
        ));

        // CWE-80: Cross-Site Scripting (XSS)
        cweSources.put("CWE-80", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getHeader(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getQueryString()Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getPathInfo()Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getRequestURI()Ljava/lang/String;",
                "javax.servlet.http.Cookie.getValue()Ljava/lang/String;"
        ));
        cweSinks.put("CWE-80", Arrays.asList(
                "java.io.PrintWriter.println(Ljava/lang/String;)V",
                "java.io.PrintWriter.print(Ljava/lang/String;)V",
                "java.io.PrintWriter.write(Ljava/lang/String;)V",
                "javax.servlet.ServletOutputStream.print(Ljava/lang/String;)V",
                "javax.servlet.ServletOutputStream.println(Ljava/lang/String;)V",
                "javax.servlet.jsp.JspWriter.print(Ljava/lang/String;)V",
                "javax.servlet.jsp.JspWriter.println(Ljava/lang/String;)V"
        ));

        // CWE-81: Improper Neutralization of Script in an Error Message Web Page
        cweSources.put("CWE-81", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getHeader(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getQueryString()Ljava/lang/String;",
                "java.lang.Exception.getMessage()Ljava/lang/String;",
                "java.lang.Throwable.toString()Ljava/lang/String;"
        ));
        cweSinks.put("CWE-81", Arrays.asList(
                "javax.servlet.http.HttpServletResponse.sendError(ILjava/lang/String;)V",
                "javax.servlet.http.HttpServletResponse.sendError(I)V"
        ));

        // CWE-83: Improper Neutralization of Script in Attributes in a Web Page
        cweSources.put("CWE-83", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getHeader(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getAttribute(Ljava/lang/String;)Ljava/lang/Object;"
        ));
        cweSinks.put("CWE-83", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.setAttribute(Ljava/lang/String;Ljava/lang/Object;)V",
                "javax.servlet.ServletContext.setAttribute(Ljava/lang/String;Ljava/lang/Object;)V",
                "javax.servlet.http.HttpSession.setAttribute(Ljava/lang/String;Ljava/lang/Object;)V"
        ));

        // CWE-89: SQL Injection
        cweSources.put("CWE-89", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "java.io.BufferedReader.readLine()Ljava/lang/String;",
                "java.util.Scanner.nextLine()Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getHeader(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getQueryString()Ljava/lang/String;"
        ));
        cweSinks.put("CWE-89", Arrays.asList(
                "java.sql.Statement.executeQuery(Ljava/lang/String;)Ljava/sql/ResultSet;",
                "java.sql.Statement.executeUpdate(Ljava/lang/String;)I",
                "java.sql.Statement.execute(Ljava/lang/String;)Z",
                "java.sql.Statement.execute(Ljava/lang/String;I)Z",
                "java.sql.Statement.addBatch(Ljava/lang/String;)V",
                "java.sql.Connection.prepareStatement(Ljava/lang/String;)Ljava/sql/PreparedStatement;",
                "java.sql.Connection.prepareCall(Ljava/lang/String;)Ljava/sql/CallableStatement;"
        ));

        // CWE-113: HTTP Response Splitting
        cweSources.put("CWE-113", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getHeader(Ljava/lang/String;)Ljava/lang/String;",
                "java.io.BufferedReader.readLine()Ljava/lang/String;",
                "javax.servlet.http.Cookie.getValue()Ljava/lang/String;"
        ));
        cweSinks.put("CWE-113", Arrays.asList(
                "javax.servlet.http.HttpServletResponse.addHeader(Ljava/lang/String;Ljava/lang/String;)V",
                "javax.servlet.http.HttpServletResponse.setHeader(Ljava/lang/String;Ljava/lang/String;)V",
                "javax.servlet.http.HttpServletResponse.addCookie(Ljavax/servlet/http/Cookie;)V",
                "javax.servlet.http.HttpServletResponse.setDateHeader(Ljava/lang/String;J)V",
                "javax.servlet.http.HttpServletResponse.addDateHeader(Ljava/lang/String;J)V",
                "javax.servlet.http.HttpServletResponse.setIntHeader(Ljava/lang/String;I)V"
        ));

        // CWE-129: Improper Validation of Array Index
        cweSources.put("CWE-129", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "java.io.BufferedReader.readLine()Ljava/lang/String;",
                "java.util.Scanner.nextLine()Ljava/lang/String;",
                "java.util.Scanner.nextInt()I",
                "java.lang.Integer.parseInt(Ljava/lang/String;)I",
                "java.lang.Integer.valueOf(Ljava/lang/String;)Ljava/lang/Integer;"
        ));
        cweSinks.put("CWE-129", Arrays.asList(
                "java.util.List.get(I)Ljava/lang/Object;",
                "java.util.ArrayList.get(I)Ljava/lang/Object;",
                "java.util.Vector.elementAt(I)Ljava/lang/Object;",
                "java.util.List.remove(I)Ljava/lang/Object;",
                "java.util.List.add(ILjava/lang/Object;)V",
                "java.util.List.set(ILjava/lang/Object;)Ljava/lang/Object;",
                "java.lang.String.substring(I)Ljava/lang/String;",
                "java.lang.String.substring(II)Ljava/lang/String;"
        ));

        // CWE-134: Uncontrolled Format String
        cweSources.put("CWE-134", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "java.io.BufferedReader.readLine()Ljava/lang/String;",
                "java.util.Scanner.nextLine()Ljava/lang/String;",
                "javax.servlet.http.HttpServletRequest.getHeader(Ljava/lang/String;)Ljava/lang/String;"
        ));
        cweSinks.put("CWE-134", Arrays.asList(
                "java.io.PrintStream.printf(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;",
                "java.io.PrintWriter.printf(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintWriter;",
                "java.lang.String.format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;",
                "java.lang.String.format(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;",
                "java.util.Formatter.format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/util/Formatter;"
        ));

        // CWE-606: Unchecked Input for Loop Condition
        cweSources.put("CWE-606", Arrays.asList(
                "javax.servlet.http.HttpServletRequest.getParameter(Ljava/lang/String;)Ljava/lang/String;",
                "java.io.BufferedReader.readLine()Ljava/lang/String;",
                "java.util.Scanner.nextLine()Ljava/lang/String;",
                "java.util.Scanner.nextInt()I",
                "java.lang.Integer.parseInt(Ljava/lang/String;)I",
                "java.lang.Integer.valueOf(Ljava/lang/String;)Ljava/lang/Integer;"
        ));
        // CWE-606 doesn't have traditional sinks - it's about loop conditions
        // The vulnerability is in the control flow, not method calls
        cweSinks.put("CWE-606", Arrays.asList());
    }

    public void scan(String filePath, String classDir, List<String> classDirs, List<String> jarPaths) throws Exception {
        File file = new File(filePath);
        JavaParser parser = new JavaParser();
        ParseResult<CompilationUnit> result = parser.parse(file);

        if (!result.isSuccessful() || !result.getResult().isPresent()) {
            System.out.println("Failed to parse the Java file.");
            return;
        }
        CompilationUnit cu = result.getResult().get();

        // Extract full qualified class name
        String packageName = cu.getPackageDeclaration().map(pd -> pd.getNameAsString() + ".").orElse("");
        String simpleClassName = extractClassName(filePath);
        String fullClassName = packageName + simpleClassName;

        System.out.println("\n=== Starting Vulnerability Analysis ===");

        // Step 1: Find sources and sinks using JavaParser (accurate line numbers)
        List<SourceInfo> taintedVariables = findSourcesAndTaint(cu);
        List<SinkInfo> sinks = findSinks(cu);

        // Step 2: Check if there's an inter-procedural path using WALA
        if (!taintedVariables.isEmpty()) {
            System.out.println("\n=== Checking Inter-procedural Taint Paths ===");
            // Pass the sources and sinks to the analyzer
            taintAnalyzer = new SimplifiedTaintAnalyzer(fullClassName, cweSources, cweSinks);

            try {
                boolean hasTaintPath = taintAnalyzer.hasTaintPath(classDir, classDirs, jarPaths);

                if (hasTaintPath) {
                    // Get details from analyzer
                    Map<String, List<SimplifiedTaintAnalyzer.TaintElement>> sinksPerCWE = taintAnalyzer.getFoundSinksPerCWE();
                    Map<String, List<SimplifiedTaintAnalyzer.TaintElement>> sourcesPerCWE = taintAnalyzer.getFoundSourcesPerCWE();

                    // Report per tainted variable (from JavaParser) and match to CWE/sinks
                    for (SourceInfo source : taintedVariables) {

                        // Find all possible CWEs for this source
                        List<String> possibleCWEs = new ArrayList<>();
                        for (Map.Entry<String, List<String>> cweEntry : cweSources.entrySet()) {
                            if (cweEntry.getValue().stream().anyMatch(s -> s.contains(source.sourceMethod))) {
                                possibleCWEs.add(cweEntry.getKey());
                            }
                        }

                        for (String cweId : possibleCWEs) {
                            if (sourcesPerCWE.containsKey(cweId) && !sourcesPerCWE.get(cweId).isEmpty() &&
                                    sinksPerCWE.containsKey(cweId) && !sinksPerCWE.get(cweId).isEmpty()) {
                                // Get the first sink for this CWE (or loop over all if needed)
                                SimplifiedTaintAnalyzer.TaintElement sink = sinksPerCWE.get(cweId).get(0);

                                String sourceFileName = new File(filePath).getName();
                                String sinkFileName = sink.sourceFileName != null ? sink.sourceFileName :
                                        (sink.containingClassName.substring(sink.containingClassName.lastIndexOf('/') + 1) + ".java");

                                System.out.println("  ✗ VULNERABILITY FOUND: " + cweId +
                                        " - Source at line " + source.line + " in file " + sourceFileName + " (" + source.sourceMethod +
                                        ") has a path to sink " + sink.methodName + " at line " + (sink.line > 0 ? sink.line : "unknown") +
                                        " in file " + sinkFileName + " (class: " + sink.className + ", method: " + sink.containingMethod + ")");

                                findings.add(new ToJson(filePath, source.line, cweId));
                                // Optionally break if only reporting once per file/CWE
                            }
                        }
                    }
                } else {
                    System.out.println("  No inter-procedural taint path found");
                }
            } catch (Exception e) {
                System.err.println("WALA analysis failed: " + e.getMessage());
                // Fall back to intra-procedural analysis
                checkIntraProceduralVulnerabilities(filePath, taintedVariables, sinks);
            }
        }

        // Step 3: Check for patterns that don't require taint (like infinite loops)
        checkNonTaintPatterns(cu, filePath);

        System.out.println("\n=== Analysis Complete ===");
        System.out.println("Total vulnerabilities found: " + findings.size());
    }

    private String extractClassName(String filePath) {
        // Extract class name from file path
        // e.g., /path/to/CWE15_External_Control_of_System_or_Configuration_Setting__Environment_54a.java
        // becomes CWE15_External_Control_of_System_or_Configuration_Setting__Environment_54a
        File file = new File(filePath);
        String fileName = file.getName();
        if (fileName.endsWith(".java")) {
            return fileName.substring(0, fileName.length() - 5);
        }
        return fileName;
    }

    private void checkIntraProceduralVulnerabilities(String filePath, List<SourceInfo> taintedVariables,
                                                     List<SinkInfo> sinks) {
        // Check if any tainted variable reaches a sink in the same file
        for (SourceInfo source : taintedVariables) {

            for (SinkInfo sink : sinks) {
                if (sink.usedVariables.contains(source.variable)) {
                    String cweId = determineCWE(source.sourceMethod, sink.sinkMethod);
                    if (cweId != null) {
                        System.out.println("  ✗ VULNERABILITY FOUND: " + cweId +
                                " - Source at line " + source.line +
                                " (" + source.sourceMethod + ") flows to sink " +
                                sink.sinkMethod + " at line " + sink.line);
                        findings.add(new ToJson(filePath, source.line, cweId));
                        break;
                    }
                }
            }
        }
    }

    // ... rest of the methods remain the same ...

    private static class SourceInfo {
        String variable;
        String sourceMethod;
        int line;

        SourceInfo(String variable, String sourceMethod, int line) {
            this.variable = variable;
            this.sourceMethod = sourceMethod;
            this.line = line;
        }
    }

    private static class SinkInfo {
        String sinkMethod;
        int line;
        Set<String> usedVariables = new HashSet<>();

        SinkInfo(String sinkMethod, int line) {
            this.sinkMethod = sinkMethod;
            this.line = line;
        }
    }

    private List<SourceInfo> findSourcesAndTaint(CompilationUnit cu) {
        List<SourceInfo> tainted = new ArrayList<>();

        System.out.println("\n=== Finding Sources ===");

        // Find variable declarations initialized with sources
        cu.findAll(VariableDeclarator.class).forEach(varDecl -> {
            if (varDecl.getInitializer().isPresent()) {
                Expression init = varDecl.getInitializer().get();
                String sourceMethod = getSourceMethod(init);
                if (sourceMethod != null) {
                    String varName = varDecl.getNameAsString();
                    int line = init.getRange().map(r -> r.begin.line).orElse(-1);
                    tainted.add(new SourceInfo(varName, sourceMethod, line));
                    System.out.println("  Found source: " + sourceMethod + " assigned to " + varName + " at line " + line);
                }
            }
        });

        // Find assignments from sources
        cu.findAll(AssignExpr.class).forEach(assign -> {
            if (assign.getTarget().isNameExpr()) {
                String sourceMethod = getSourceMethod(assign.getValue());
                if (sourceMethod != null) {
                    String varName = assign.getTarget().asNameExpr().getNameAsString();
                    int line = assign.getValue().getRange().map(r -> r.begin.line).orElse(-1);
                    tainted.add(new SourceInfo(varName, sourceMethod, line));
                    System.out.println("  Found source: " + sourceMethod + " assigned to " + varName + " at line " + line);
                }
            }
        });

        return tainted;
    }

    private String getSourceMethod(Expression expr) {
        if (expr.isMethodCallExpr()) {
            MethodCallExpr call = expr.asMethodCallExpr();
            String methodName = call.getNameAsString();

            // Check if this is a known source
            for (List<String> sources : cweSources.values()) {
                if (sources.stream().anyMatch(sig -> sig.contains(methodName))) {
                    // Special check for System.getenv
                    if (methodName.equals("getenv") && call.getScope().isPresent() &&
                            call.getScope().get().toString().equals("System")) {
                        return "System.getenv";
                    }
                    return methodName;
                }
            }
        }
        return null;
    }

    private List<SinkInfo> findSinks(CompilationUnit cu) {
        List<SinkInfo> sinks = new ArrayList<>();

        System.out.println("\n=== Finding Sinks ===");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();

            // Check if this is a known sink
            for (List<String> sinkList : cweSinks.values()) {
                if (sinkList.stream().anyMatch(sig -> sig.contains(methodName))) {
                    int line = call.getRange().map(r -> r.begin.line).orElse(-1);
                    SinkInfo sink = new SinkInfo(methodName, line);

                    // Track which variables are used in this sink call (recursively from expressions)
                    call.getArguments().forEach(arg -> {
                        sink.usedVariables.addAll(collectUsedVariables(arg));
                    });

                    sinks.add(sink);
                    System.out.println("  Found sink: " + methodName + " at line " + line);
                    break;
                }
            }
        });

        return sinks;
    }

    private Set<String> collectUsedVariables(Expression expr) {
        Set<String> vars = new HashSet<>();
        expr.findAll(NameExpr.class).forEach(ne -> vars.add(ne.getNameAsString()));
        return vars;
    }

    private String determineCWE(String source, String sink) {
        // Check each CWE's source/sink combination
        for (Map.Entry<String, List<String>> entry : cweSources.entrySet()) {
            String cweId = entry.getKey();
            List<String> sources = entry.getValue();
            List<String> sinks = cweSinks.get(cweId);

            if (sources != null && sinks != null) {
                boolean sourceMatches = sources.stream().anyMatch(sig -> sig.contains(source));
                boolean sinkMatches = (sink == null) || sinks.stream().anyMatch(sig -> sig.contains(sink));

                if (sourceMatches && sinkMatches) {
                    return cweId;
                }
            }
        }

        return null;
    }

    private void checkNonTaintPatterns(CompilationUnit cu, String filePath) {
        JsonObject patterns = loader.getPatterns();

        // Check for patterns that don't require taint analysis (like infinite loops)
        if (patterns.has("CWE-835")) {
            System.out.println("\nChecking for CWE-835: Infinite Loop");
            JsonObject cweObj = patterns.get("CWE-835").getAsJsonObject();
            if (cweObj.has("ast_patterns")) {
                JsonArray astPatterns = cweObj.getAsJsonArray("ast_patterns");

                for (JsonElement patEl : astPatterns) {
                    JsonObject pattern = patEl.getAsJsonObject();
                    String nodeType = pattern.get("node_type").getAsString();

                    switch (nodeType) {
                        case "WhileStmt":
                            cu.findAll(WhileStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                        case "ForStmt":
                            cu.findAll(ForStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                        case "DoStmt":
                            cu.findAll(DoStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                    }
                }
            }
        }
    }

    public static void exportFindingsToJson(List<ToJson> findings, String outputPath) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(outputPath)) {
            gson.toJson(findings, writer);
            System.out.println("\nExported results to " + outputPath);
        } catch (Exception e) {
            System.out.println("Error writing JSON: " + e.getMessage());
        }
    }

    public java.util.List<ToJson> getFindings() {
        return findings;
    }
}
