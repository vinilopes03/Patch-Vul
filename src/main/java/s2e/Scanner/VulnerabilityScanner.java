package s2e.Scanner;

import s2e.PatchGenerator.ToJson;
import s2e.PatternAnalyzer.*;
import s2e.WalaIntegration.SimplifiedTaintAnalyzer;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.stmt.ForStmt;
import com.github.javaparser.ast.stmt.WhileStmt;
import com.github.javaparser.ast.stmt.DoStmt;
import com.google.gson.*;
import s2e.WalaIntegration.*;
import java.io.File;
import java.io.FileWriter;
import java.util.*;

public class VulnerabilityScanner {
    private final PatternLoader loader;
    private final PatternMatcher matcher;
    private final List<ToJson> findings = new java.util.ArrayList<>();
    private SimplifiedTaintAnalyzer taintAnalyzer;

    // Track sources and sinks from patterns
    private Map<String, List<String>> cweSources = new HashMap<>();
    private Map<String, List<String>> cweSinks = new HashMap<>();

    public VulnerabilityScanner(String patternPath) throws Exception {
        loader = new PatternLoader(patternPath);
        matcher = new PatternMatcher();
        initializeSourcesAndSinks();
    }

    private void initializeSourcesAndSinks() {
        // Initialize based on patterns
        cweSources.put("CWE-15", Arrays.asList("getenv"));
        cweSinks.put("CWE-15", Arrays.asList("setProperty", "clearProperty", "setCatalog",
                "setSchema", "setSessionContext", "setLogWriter",
                "setLoginTimeout", "lookup", "setRequestProperty",
                "addRequestProperty"));

        cweSources.put("CWE-78", Arrays.asList("getParameter", "readLine", "nextLine"));
        cweSinks.put("CWE-78", Arrays.asList("exec"));

        cweSources.put("CWE-89", Arrays.asList("getParameter", "readLine", "nextLine"));
        cweSinks.put("CWE-89", Arrays.asList("executeQuery", "executeUpdate", "execute"));
    }

    public void scan(String filePath, String classDir, List<String> classDirs, List<String> jarPaths) throws Exception {
        File file = new File(filePath);
        JavaParser parser = new JavaParser();
        ParseResult<CompilationUnit> result = parser.parse(file);

        if (!result.isSuccessful() || !result.getResult().isPresent()) {
            System.out.println("Failed to parse the Java file.");
            return;
        }
        CompilationUnit cu = result.getResult().get();

        System.out.println("\n=== Starting Vulnerability Analysis ===");

        // Step 1: Find sources and sinks using JavaParser (accurate line numbers)
        Map<String, SourceInfo> taintedVariables = findSourcesAndTaint(cu);
        List<SinkInfo> sinks = findSinks(cu);

        // Step 2: Check if there's an inter-procedural path using WALA
        if (!taintedVariables.isEmpty()) {
            // Extract the target class name from the file path
            String targetClassName = extractClassName(filePath);

            System.out.println("\n=== Checking Inter-procedural Taint Paths ===");
            // Pass the sources and sinks to the analyzer
            taintAnalyzer = new SimplifiedTaintAnalyzer(targetClassName, cweSources, cweSinks);

            try {
                boolean hasTaintPath = taintAnalyzer.hasTaintPath(classDir, classDirs, jarPaths);

                if (hasTaintPath) {
                    // Get details from analyzer
                    Map<String, List<SimplifiedTaintAnalyzer.TaintElement>> sinksPerCWE = taintAnalyzer.getFoundSinksPerCWE();
                    Map<String, List<SimplifiedTaintAnalyzer.TaintElement>> sourcesPerCWE = taintAnalyzer.getFoundSourcesPerCWE();

                    // Report per tainted variable (from JavaParser) and match to CWE/sinks
                    for (Map.Entry<String, SourceInfo> entry : taintedVariables.entrySet()) {
                        SourceInfo source = entry.getValue();

                        // Find all possible CWEs for this source
                        List<String> possibleCWEs = new ArrayList<>();
                        for (Map.Entry<String, List<String>> cweEntry : cweSources.entrySet()) {
                            if (cweEntry.getValue().stream().anyMatch(s -> source.sourceMethod.contains(s))) {
                                possibleCWEs.add(cweEntry.getKey());
                            }
                        }

                        for (String cweId : possibleCWEs) {
                            if (sourcesPerCWE.containsKey(cweId) && !sourcesPerCWE.get(cweId).isEmpty() &&
                                    sinksPerCWE.containsKey(cweId) && !sinksPerCWE.get(cweId).isEmpty()) {
                                // Get the first sink for this CWE (or loop over all if needed)
                                SimplifiedTaintAnalyzer.TaintElement sink = sinksPerCWE.get(cweId).get(0);

                                String sourceFileName = new File(filePath).getName();
                                String sinkFileName = sink.sourceFileName != null ? sink.sourceFileName :
                                        (sink.containingClassName.substring(sink.containingClassName.lastIndexOf('/') + 1) + ".java");

                                System.out.println("  ✗ VULNERABILITY FOUND: " + cweId +
                                        " - Source at line " + source.line + " in file " + sourceFileName + " (" + source.sourceMethod +
                                        ") has a path to sink " + sink.methodName + " at line " + (sink.line > 0 ? sink.line : "unknown") +
                                        " in file " + sinkFileName + " (class: " + sink.className + ", method: " + sink.containingMethod + ")");

                                findings.add(new ToJson(filePath, source.line, cweId));
                                // Optionally break if only reporting once per file/CWE
                            }
                        }
                    }
                } else {
                    System.out.println("  No inter-procedural taint path found");
                }
            } catch (Exception e) {
                System.err.println("WALA analysis failed: " + e.getMessage());
                // Fall back to intra-procedural analysis
                checkIntraProceduralVulnerabilities(filePath, taintedVariables, sinks);
            }
        }

        // Step 3: Check for patterns that don't require taint (like infinite loops)
        checkNonTaintPatterns(cu, filePath);

        System.out.println("\n=== Analysis Complete ===");
        System.out.println("Total vulnerabilities found: " + findings.size());
    }

    private String extractClassName(String filePath) {
        // Extract class name from file path
        // e.g., /path/to/CWE15_External_Control_of_System_or_Configuration_Setting__Environment_54a.java
        // becomes CWE15_External_Control_of_System_or_Configuration_Setting__Environment_54a
        File file = new File(filePath);
        String fileName = file.getName();
        if (fileName.endsWith(".java")) {
            return fileName.substring(0, fileName.length() - 5);
        }
        return fileName;
    }

    private void checkIntraProceduralVulnerabilities(String filePath, Map<String, SourceInfo> taintedVariables,
                                                     List<SinkInfo> sinks) {
        // Check if any tainted variable reaches a sink in the same file
        for (Map.Entry<String, SourceInfo> entry : taintedVariables.entrySet()) {
            String varName = entry.getKey();
            SourceInfo source = entry.getValue();

            for (SinkInfo sink : sinks) {
                if (sink.usedVariables.contains(varName)) {
                    String cweId = determineCWE(source.sourceMethod, sink.sinkMethod);
                    if (cweId != null) {
                        System.out.println("  ✗ VULNERABILITY FOUND: " + cweId +
                                " - Source at line " + source.line +
                                " (" + source.sourceMethod + ") flows to sink " +
                                sink.sinkMethod + " at line " + sink.line);
                        findings.add(new ToJson(filePath, source.line, cweId));
                        break;
                    }
                }
            }
        }
    }

    // ... rest of the methods remain the same ...

    private static class SourceInfo {
        String variable;
        String sourceMethod;
        int line;

        SourceInfo(String variable, String sourceMethod, int line) {
            this.variable = variable;
            this.sourceMethod = sourceMethod;
            this.line = line;
        }
    }

    private static class SinkInfo {
        String sinkMethod;
        int line;
        Set<String> usedVariables = new HashSet<>();

        SinkInfo(String sinkMethod, int line) {
            this.sinkMethod = sinkMethod;
            this.line = line;
        }
    }

    private Map<String, SourceInfo> findSourcesAndTaint(CompilationUnit cu) {
        Map<String, SourceInfo> tainted = new HashMap<>();

        System.out.println("\n=== Finding Sources ===");

        // Find variable declarations initialized with sources
        cu.findAll(VariableDeclarator.class).forEach(varDecl -> {
            if (varDecl.getInitializer().isPresent()) {
                Expression init = varDecl.getInitializer().get();
                String sourceMethod = getSourceMethod(init);
                if (sourceMethod != null) {
                    String varName = varDecl.getNameAsString();
                    int line = init.getRange().map(r -> r.begin.line).orElse(-1);
                    tainted.put(varName, new SourceInfo(varName, sourceMethod, line));
                    System.out.println("  Found source: " + sourceMethod + " assigned to " + varName + " at line " + line);
                }
            }
        });

        // Find assignments from sources
        cu.findAll(AssignExpr.class).forEach(assign -> {
            if (assign.getTarget().isNameExpr()) {
                String sourceMethod = getSourceMethod(assign.getValue());
                if (sourceMethod != null) {
                    String varName = assign.getTarget().asNameExpr().getNameAsString();
                    int line = assign.getValue().getRange().map(r -> r.begin.line).orElse(-1);
                    tainted.put(varName, new SourceInfo(varName, sourceMethod, line));
                    System.out.println("  Found source: " + sourceMethod + " assigned to " + varName + " at line " + line);
                }
            }
        });

        return tainted;
    }

    private String getSourceMethod(Expression expr) {
        if (expr.isMethodCallExpr()) {
            MethodCallExpr call = expr.asMethodCallExpr();
            String methodName = call.getNameAsString();

            // Check if this is a known source
            for (List<String> sources : cweSources.values()) {
                if (sources.contains(methodName)) {
                    // Special check for System.getenv
                    if (methodName.equals("getenv") && call.getScope().isPresent() &&
                            call.getScope().get().toString().equals("System")) {
                        return "System.getenv";
                    }
                    return methodName;
                }
            }
        }
        return null;
    }

    private List<SinkInfo> findSinks(CompilationUnit cu) {
        List<SinkInfo> sinks = new ArrayList<>();

        System.out.println("\n=== Finding Sinks ===");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();

            // Check if this is a known sink
            for (List<String> sinkList : cweSinks.values()) {
                if (sinkList.contains(methodName)) {
                    int line = call.getRange().map(r -> r.begin.line).orElse(-1);
                    SinkInfo sink = new SinkInfo(methodName, line);

                    // Track which variables are used in this sink call (recursively from expressions)
                    call.getArguments().forEach(arg -> {
                        sink.usedVariables.addAll(collectUsedVariables(arg));
                    });

                    sinks.add(sink);
                    System.out.println("  Found sink: " + methodName + " at line " + line);
                    break;
                }
            }
        });

        return sinks;
    }

    private Set<String> collectUsedVariables(Expression expr) {
        Set<String> vars = new HashSet<>();
        expr.findAll(NameExpr.class).forEach(ne -> vars.add(ne.getNameAsString()));
        return vars;
    }

    private String determineCWE(String source, String sink) {
        // Check each CWE's source/sink combination
        for (Map.Entry<String, List<String>> entry : cweSources.entrySet()) {
            String cweId = entry.getKey();
            List<String> sources = entry.getValue();
            List<String> sinks = cweSinks.get(cweId);

            if (sources != null && sinks != null) {
                boolean sourceMatches = sources.stream().anyMatch(s -> source.contains(s));
                boolean sinkMatches = (sink == null) || sinks.contains(sink);

                if (sourceMatches && sinkMatches) {
                    return cweId;
                }
            }
        }

        return null;
    }

    private void checkNonTaintPatterns(CompilationUnit cu, String filePath) {
        JsonObject patterns = loader.getPatterns();

        // Check for patterns that don't require taint analysis (like infinite loops)
        if (patterns.has("CWE-835")) {
            System.out.println("\nChecking for CWE-835: Infinite Loop");
            JsonObject cweObj = patterns.get("CWE-835").getAsJsonObject();
            if (cweObj.has("ast_patterns")) {
                JsonArray astPatterns = cweObj.getAsJsonArray("ast_patterns");

                for (JsonElement patEl : astPatterns) {
                    JsonObject pattern = patEl.getAsJsonObject();
                    String nodeType = pattern.get("node_type").getAsString();

                    switch (nodeType) {
                        case "WhileStmt":
                            cu.findAll(WhileStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                        case "ForStmt":
                            cu.findAll(ForStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                        case "DoStmt":
                            cu.findAll(DoStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                    }
                }
            }
        }
    }

    public static void exportFindingsToJson(List<ToJson> findings, String outputPath) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(outputPath)) {
            gson.toJson(findings, writer);
            System.out.println("\nExported results to " + outputPath);
        } catch (Exception e) {
            System.out.println("Error writing JSON: " + e.getMessage());
        }
    }

    public java.util.List<ToJson> getFindings() {
        return findings;
    }
}