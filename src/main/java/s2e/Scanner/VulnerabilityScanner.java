package s2e.Scanner;

import s2e.PatchGenerator.ToJson;
import s2e.PatternAnalyzer.*;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.ArrayAccessExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.stmt.ForStmt;
import com.github.javaparser.ast.stmt.WhileStmt;
import com.github.javaparser.ast.stmt.DoStmt;
import com.google.gson.*;

import java.io.File;
import java.io.FileWriter;
import java.util.*;

public class VulnerabilityScanner {
    private final PatternLoader loader;
    private final PatternMatcher matcher;
    private final List<ToJson> findings = new java.util.ArrayList<>();

    // Track sources and sinks from patterns
    private Map<String, List<String>> cweSources = new HashMap<>();
    private Map<String, List<String>> cweSinks = new HashMap<>();

    public VulnerabilityScanner(String patternPath) throws Exception {
        loader = new PatternLoader(patternPath);
        matcher = new PatternMatcher();
        initializeSourcesAndSinks();
    }

    private void initializeSourcesAndSinks() {
        // Initialize based on patterns - could be enhanced to read from pattern.json
        cweSources.put("CWE-15", Arrays.asList("getenv"));
        cweSinks.put("CWE-15", Arrays.asList("setProperty", "clearProperty", "setCatalog",
                "setSchema", "setSessionContext", "setLogWriter",
                "setLoginTimeout", "lookup", "setRequestProperty",
                "addRequestProperty"));

        cweSources.put("CWE-78", Arrays.asList("getParameter", "readLine", "nextLine"));
        cweSinks.put("CWE-78", Arrays.asList("exec"));

        cweSources.put("CWE-89", Arrays.asList("getParameter", "readLine", "nextLine"));
        cweSinks.put("CWE-89", Arrays.asList("executeQuery", "executeUpdate", "execute"));

        // Add more CWEs as needed
    }

    public void scan(String filePath, String classDir, List<String> classDirs, List<String> jarPaths) throws Exception {
        File file = new File(filePath);
        JavaParser parser = new JavaParser();
        ParseResult<CompilationUnit> result = parser.parse(file);

        if (!result.isSuccessful() || !result.getResult().isPresent()) {
            System.out.println("Failed to parse the Java file.");
            return;
        }
        CompilationUnit cu = result.getResult().get();

        System.out.println("\n=== Starting Vulnerability Analysis ===");

        // Step 1: Find all sources and track tainted variables
        Map<String, SourceInfo> taintedVariables = findSourcesAndTaint(cu);

        // Step 2: Find all sinks
        List<SinkInfo> sinks = findSinks(cu);

        // Step 3: Check if any tainted variable reaches a sink
        for (Map.Entry<String, SourceInfo> entry : taintedVariables.entrySet()) {
            String varName = entry.getKey();
            SourceInfo source = entry.getValue();

            // Check if this tainted variable is used in any sink
            for (SinkInfo sink : sinks) {
                if (sink.usesVariable(varName)) {
                    // Determine CWE based on source and sink combination
                    String cweId = determineCWE(source.sourceMethod, sink.sinkMethod);
                    if (cweId != null) {
                        System.out.println("  ✗ VULNERABILITY FOUND: " + cweId +
                                " - Source at line " + source.line +
                                " (" + source.sourceMethod + ") flows to sink " +
                                sink.sinkMethod + " at line " + sink.line);
                        findings.add(new ToJson(filePath, source.line, cweId));
                        break; // Only report once per source
                    }
                }
            }
        }

        // Step 4: Check for patterns that don't require taint (like infinite loops)
        checkNonTaintPatterns(cu, filePath);

        System.out.println("\n=== Analysis Complete ===");
        System.out.println("Total vulnerabilities found: " + findings.size());
    }

    private static class SourceInfo {
        String variable;
        String sourceMethod;
        int line;

        SourceInfo(String variable, String sourceMethod, int line) {
            this.variable = variable;
            this.sourceMethod = sourceMethod;
            this.line = line;
        }
    }

    private static class SinkInfo {
        String sinkMethod;
        int line;
        Set<String> usedVariables = new HashSet<>();

        SinkInfo(String sinkMethod, int line) {
            this.sinkMethod = sinkMethod;
            this.line = line;
        }

        void addUsedVariable(String var) {
            usedVariables.add(var);
        }

        boolean usesVariable(String var) {
            return usedVariables.contains(var);
        }
    }

    private Map<String, SourceInfo> findSourcesAndTaint(CompilationUnit cu) {
        Map<String, SourceInfo> tainted = new HashMap<>();

        System.out.println("\n=== Finding Sources ===");

        // Find variable declarations initialized with sources
        cu.findAll(VariableDeclarator.class).forEach(varDecl -> {
            if (varDecl.getInitializer().isPresent()) {
                Expression init = varDecl.getInitializer().get();
                String sourceMethod = getSourceMethod(init);
                if (sourceMethod != null) {
                    String varName = varDecl.getNameAsString();
                    int line = init.getRange().map(r -> r.begin.line).orElse(-1);
                    tainted.put(varName, new SourceInfo(varName, sourceMethod, line));
                    System.out.println("  Found source: " + sourceMethod + " assigned to " + varName + " at line " + line);
                }
            }
        });

        // Find assignments from sources
        cu.findAll(AssignExpr.class).forEach(assign -> {
            if (assign.getTarget().isNameExpr()) {
                String sourceMethod = getSourceMethod(assign.getValue());
                if (sourceMethod != null) {
                    String varName = assign.getTarget().asNameExpr().getNameAsString();
                    int line = assign.getValue().getRange().map(r -> r.begin.line).orElse(-1);
                    tainted.put(varName, new SourceInfo(varName, sourceMethod, line));
                    System.out.println("  Found source: " + sourceMethod + " assigned to " + varName + " at line " + line);
                }
            }
        });

        return tainted;
    }

    private String getSourceMethod(Expression expr) {
        if (expr.isMethodCallExpr()) {
            MethodCallExpr call = expr.asMethodCallExpr();
            String methodName = call.getNameAsString();

            // Check if this is a known source
            for (List<String> sources : cweSources.values()) {
                if (sources.contains(methodName)) {
                    // Special check for System.getenv
                    if (methodName.equals("getenv") && call.getScope().isPresent() &&
                            call.getScope().get().toString().equals("System")) {
                        return "System.getenv";
                    }
                    return methodName;
                }
            }
        }
        return null;
    }

    private List<SinkInfo> findSinks(CompilationUnit cu) {
        List<SinkInfo> sinks = new ArrayList<>();

        System.out.println("\n=== Finding Sinks ===");

        cu.findAll(MethodCallExpr.class).forEach(call -> {
            String methodName = call.getNameAsString();

            // Check if this is a known sink
            for (List<String> sinkList : cweSinks.values()) {
                if (sinkList.contains(methodName)) {
                    int line = call.getRange().map(r -> r.begin.line).orElse(-1);
                    SinkInfo sink = new SinkInfo(methodName, line);

                    // Track which variables are used in this sink call
                    call.getArguments().forEach(arg -> {
                        if (arg.isNameExpr()) {
                            sink.addUsedVariable(arg.asNameExpr().getNameAsString());
                        }
                    });

                    sinks.add(sink);
                    System.out.println("  Found sink: " + methodName + " at line " + line);
                    break;
                }
            }
        });

        return sinks;
    }

    private String determineCWE(String source, String sink) {
        // Check each CWE's source/sink combination
        for (Map.Entry<String, List<String>> entry : cweSources.entrySet()) {
            String cweId = entry.getKey();
            List<String> sources = entry.getValue();
            List<String> sinks = cweSinks.get(cweId);

            if (sources != null && sinks != null) {
                boolean sourceMatches = sources.stream().anyMatch(s -> source.contains(s));
                boolean sinkMatches = sinks.contains(sink);

                if (sourceMatches && sinkMatches) {
                    return cweId;
                }
            }
        }

        // Special case for CWE-15 where System.getenv itself is the vulnerability
        if (source.contains("getenv")) {
            return "CWE-15";
        }

        return null;
    }

    private void checkNonTaintPatterns(CompilationUnit cu, String filePath) {
        JsonObject patterns = loader.getPatterns();

        // Check for patterns that don't require taint analysis (like infinite loops)
        if (patterns.has("CWE-835")) {
            System.out.println("\nChecking for CWE-835: Infinite Loop");
            JsonObject cweObj = patterns.get("CWE-835").getAsJsonObject();
            if (cweObj.has("ast_patterns")) {
                JsonArray astPatterns = cweObj.getAsJsonArray("ast_patterns");

                for (JsonElement patEl : astPatterns) {
                    JsonObject pattern = patEl.getAsJsonObject();
                    String nodeType = pattern.get("node_type").getAsString();

                    switch (nodeType) {
                        case "WhileStmt":
                            cu.findAll(WhileStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                        case "ForStmt":
                            cu.findAll(ForStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                        case "DoStmt":
                            cu.findAll(DoStmt.class).forEach(node -> {
                                if (matcher.matchesPattern(node, pattern)) {
                                    int line = node.getRange().map(r -> r.begin.line).orElse(-1);
                                    System.out.println("  ✗ VULNERABILITY FOUND: CWE-835 at line " + line);
                                    findings.add(new ToJson(filePath, line, "CWE-835"));
                                }
                            });
                            break;
                    }
                }
            }
        }
    }

    public static void exportFindingsToJson(List<ToJson> findings, String outputPath) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(outputPath)) {
            gson.toJson(findings, writer);
            System.out.println("\nExported results to " + outputPath);
        } catch (Exception e) {
            System.out.println("Error writing JSON: " + e.getMessage());
        }
    }

    public java.util.List<ToJson> getFindings() {
        return findings;
    }
}