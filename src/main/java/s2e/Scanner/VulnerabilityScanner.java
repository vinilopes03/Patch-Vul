package s2e.Scanner;

import s2e.PatchGenerator.ToJson;
import s2e.PatternAnalyzer.*;
import s2e.WalaIntegration.SimplifiedTaintAnalyzer;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.google.gson.*;
import s2e.WalaIntegration.*;
import java.io.File;
import java.io.FileWriter;
import java.util.*;

public class VulnerabilityScanner {
    private final PatternLoader loader;
    private final PatternMatcher matcher;
    private final List<ToJson> findings = new java.util.ArrayList<>();
    private SimplifiedTaintAnalyzer taintAnalyzer;

    // Track sources, sinks, and sanitizers from JSON
    private Map<String, List<String>> cweSources = new HashMap<>();
    private Map<String, List<String>> cweSinks = new HashMap<>();
    private Map<String, List<String>> cweSanitizers = new HashMap<>();

    public VulnerabilityScanner(String patternPath) throws Exception {
        loader = new PatternLoader(patternPath);
        matcher = new PatternMatcher();
        initializeFromJson();
    }

    private void initializeFromJson() {
        JsonObject patterns = loader.getPatterns();
        for (String cweId : patterns.keySet()) {
            JsonObject cweObj = patterns.getAsJsonObject(cweId);
            if (cweObj.has("sources")) {
                JsonArray sourcesArray = cweObj.getAsJsonArray("sources");
                List<String> sources = new ArrayList<>();
                for (JsonElement elem : sourcesArray) {
                    sources.add(elem.getAsString());
                }
                cweSources.put(cweId, sources);
            }
            if (cweObj.has("sinks")) {
                JsonArray sinksArray = cweObj.getAsJsonArray("sinks");
                List<String> sinks = new ArrayList<>();
                for (JsonElement elem : sinksArray) {
                    sinks.add(elem.getAsString());
                }
                cweSinks.put(cweId, sinks);
            }
            if (cweObj.has("sanitizers")) {
                JsonArray sanitizersArray = cweObj.getAsJsonArray("sanitizers");
                List<String> sanitizers = new ArrayList<>();
                for (JsonElement elem : sanitizersArray) {
                    sanitizers.add(elem.getAsString());
                }
                cweSanitizers.put(cweId, sanitizers);
            }
        }
        System.out.println("Loaded " + patterns.keySet().size() + " CWEs from JSON: " + String.join(", ", patterns.keySet()));
    }

    public void scan(String filePath, String classDir, List<String> classDirs, List<String> jarPaths) throws Exception {
        File file = new File(filePath);
        JavaParser parser = new JavaParser();
        ParseResult<CompilationUnit> result = parser.parse(file);

        if (!result.isSuccessful() || !result.getResult().isPresent()) {
            System.out.println("Failed to parse the Java file.");
            return;
        }
        CompilationUnit cu = result.getResult().get();

        // Extract full qualified class name
        String packageName = cu.getPackageDeclaration().map(pd -> pd.getNameAsString() + ".").orElse("");
        String simpleClassName = extractClassName(filePath);
        String fullClassName = packageName + simpleClassName;

        System.out.println("\n=== Starting Vulnerability Analysis ===");

        // Step 1: Find sources and taint using JavaParser (accurate line numbers)
        List<SourceInfo> taintedVariables = findSourcesAndTaint(cu);
        // Step 2: Check if there's an inter-procedural path using WALA
        if (!taintedVariables.isEmpty()) {
            System.out.println("\n=== Checking Inter-procedural Taint Paths ===");
            taintAnalyzer = new SimplifiedTaintAnalyzer(fullClassName, cweSources, cweSinks, cweSanitizers);

            boolean hasTaintPath = taintAnalyzer.hasTaintPath(classDir, classDirs, jarPaths);

            if (hasTaintPath) {
                // Get details from analyzer, per entrypoint
                Map<String, Map<String, List<SimplifiedTaintAnalyzer.TaintElement>>> sinksByEntryPerCWE = taintAnalyzer.getFoundSinksByEntryPerCWE();

                // Report per tainted variable (from JavaParser) and match to CWE/sinks reachable from the source's method
                for (SourceInfo source : taintedVariables) {

                    // Find all possible CWEs for this source
                    List<String> possibleCWEs = new ArrayList<>();
                    for (Map.Entry<String, List<String>> cweEntry : cweSources.entrySet()) {
                        if (cweEntry.getValue().stream().anyMatch(s -> s.contains(source.sourceMethod))) {
                            possibleCWEs.add(cweEntry.getKey());
                        }
                    }

                    for (String cweId : possibleCWEs) {
                        // Get sinks only for the entrypoint matching the source's containing method
                        Map<String, List<SimplifiedTaintAnalyzer.TaintElement>> sinksPerCWEForEntry = sinksByEntryPerCWE.getOrDefault(source.containingMethod, new HashMap<>());
                        List<SimplifiedTaintAnalyzer.TaintElement> taintedSinks = sinksPerCWEForEntry.getOrDefault(cweId, new ArrayList<>());
                        if (!taintedSinks.isEmpty()) {
                            findings.add(new ToJson(filePath, source.line, cweId));

                            for (SimplifiedTaintAnalyzer.TaintElement sink : taintedSinks) {
                                String sourceFileName = new File(filePath).getName();
                                String sinkFileName = sink.sourceFileName != null ? sink.sourceFileName :
                                        (sink.containingClassName.substring(sink.containingClassName.lastIndexOf('/') + 1) + ".java");

                                System.out.println("  âœ— VULNERABILITY FOUND: " + cweId +
                                        " - Source at line " + source.line + " in file " + sourceFileName + " (" + source.sourceMethod +
                                        ") has a path to sink " + sink.methodName + " at line " + (sink.line > 0 ? sink.line : "unknown") +
                                        " in file " + sinkFileName + " (class: " + sink.className + ", method: " + sink.containingMethod + ")");
                            }
                        }
                    }
                }
            } else {
                System.out.println("  No inter-procedural taint path found");
            }
        }

        System.out.println("\n=== Analysis Complete ===");
        System.out.println("Total vulnerabilities found: " + findings.size());
    }

    private String extractClassName(String filePath) {
        // Extract class name from file path
        // e.g., /path/to/CWE15_External_Control_of_System_or_Configuration_Setting__Environment_54a.java
        // becomes CWE15_External_Control_of_System_or_Configuration_Setting__Environment_54a
        File file = new File(filePath);
        String fileName = file.getName();
        if (fileName.endsWith(".java")) {
            return fileName.substring(0, fileName.length() - 5);
        }
        return fileName;
    }

    private List<SourceInfo> findSourcesAndTaint(CompilationUnit cu) {
        List<SourceInfo> tainted = new ArrayList<>();

        System.out.println("\n=== Finding Sources ===");

        // Find variable declarations initialized with sources
        cu.findAll(VariableDeclarator.class).forEach(varDecl -> {
            if (varDecl.getInitializer().isPresent()) {
                Expression init = varDecl.getInitializer().get();
                String sourceMethod = getSourceMethod(init);
                if (sourceMethod != null) {
                    String varName = varDecl.getNameAsString();
                    int line = init.getRange().map(r -> r.begin.line).orElse(-1);
                    String containingMethod = varDecl.findAncestor(MethodDeclaration.class)
                            .map(MethodDeclaration::getNameAsString).orElse("unknown");
                    tainted.add(new SourceInfo(varName, sourceMethod, line, containingMethod));
                    System.out.println("  Found source: " + sourceMethod + " assigned to " + varName + " at line " + line + " in " + containingMethod);
                }
            }
        });

        // Find assignments from sources
        cu.findAll(AssignExpr.class).forEach(assign -> {
            if (assign.getTarget().isNameExpr()) {
                String sourceMethod = getSourceMethod(assign.getValue());
                if (sourceMethod != null) {
                    String varName = assign.getTarget().asNameExpr().getNameAsString();
                    int line = assign.getValue().getRange().map(r -> r.begin.line).orElse(-1);
                    String containingMethod = assign.findAncestor(MethodDeclaration.class)
                            .map(MethodDeclaration::getNameAsString).orElse("unknown");
                    tainted.add(new SourceInfo(varName, sourceMethod, line, containingMethod));
                    System.out.println("  Found source: " + sourceMethod + " assigned to " + varName + " at line " + line + " in " + containingMethod);
                }
            }
        });

        return tainted;
    }

    private String getSourceMethod(Expression expr) {
        if (expr.isMethodCallExpr()) {
            MethodCallExpr call = expr.asMethodCallExpr();
            String methodName = call.getNameAsString();

            // Check if this is a known source
            for (List<String> sources : cweSources.values()) {
                if (sources.stream().anyMatch(sig -> sig.contains(methodName))) {
                    // Special check for System.getenv
                    if (methodName.equals("getenv") && call.getScope().isPresent() &&
                            call.getScope().get().toString().equals("System")) {
                        return "System.getenv";
                    }
                    return methodName;
                }
            }
        }
        return null;
    }

    public static void exportFindingsToJson(List<ToJson> findings, String outputPath) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(outputPath)) {
            gson.toJson(findings, writer);
            System.out.println("\nExported results to " + outputPath);
        } catch (Exception e) {
            System.out.println("Error writing JSON: " + e.getMessage());
        }
    }

    public java.util.List<ToJson> getFindings() {
        return findings;
    }

    private static class SourceInfo {
        String variable;
        String sourceMethod;
        int line;
        String containingMethod;

        SourceInfo(String variable, String sourceMethod, int line, String containingMethod) {
            this.variable = variable;
            this.sourceMethod = sourceMethod;
            this.line = line;
            this.containingMethod = containingMethod;
        }
    }
}